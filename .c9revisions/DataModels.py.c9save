{"ts":1373152562668,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"import logging, json, datetime\nfrom decimal import *\n\n#App Engine platform\nfrom google.appengine.api import mail, memcache, datastore_errors, taskqueue\nfrom google.appengine.ext import ndb, blobstore\n\n#Search\nfrom google.appengine.api import search\n\nimport GlobalUtilities as tools\n\n_CONTACT_SEARCH_INDEX = \"contact\"\n_DEPOSIT_SEARCH_INDEX = \"deposit\"\n_DONATION_SEARCH_INDEX = \"donation\"\n_INDIVIDUAL_SEARCH_INDEX = \"individual\"\n_TEAM_SEARCH_INDEX = \"team\"\n\nclass DecimalProperty(ndb.StringProperty):\n    def _validate(self, value):\n        if not isinstance(value, (Decimal, str)):\n            raise datastore_errors.BadValueError('Expected decimal or string, got %r' % (value,))\n\n        return value\n\n    def _to_base_type(self, value):\n        return str(value)\n\n    def _from_base_type(self, value):\n        return tools.toDecimal(value)\n\n###### ////// ------ Define datastore models ------ ////// ######\nclass Contact(ndb.Expando):\n    #Standard information we need to know\n    name = ndb.StringProperty()\n    email = ndb.StringProperty(repeated=True)\n    phone = ndb.StringProperty()\n    address = ndb.StringProperty(repeated=True)\n    notes = ndb.TextProperty(indexed=True)\n    \n    settings = ndb.KeyProperty()\n\n    #Sets creation date\n    creation_date = ndb.DateTimeProperty(auto_now_add=True)\n\n    @property\n    def address_json(self):\n        return json.dumps(self.address)\n\n    @property\n    def address_formatted(self):\n        a = self.address\n        if not a == [\"\", \"\", \"\", \"\"]:\n            return a[0] + \"\\n\" + a[1] + \", \" + a[2] + \"  \" + a[3]\n        else:\n            return \"\"\n\n    @property\n    def create(self):\n        return tools.ContactCreate(self)\n\n    @property\n    def data(self):\n        return tools.ContactData(self)\n\n    @property\n    def search(self):\n        return tools.ContactSearch(self)\n\n    @property\n    def websafe(self):\n        return self.key.urlsafe()\n\n    ## -- Update contact -- ##\n    def update(self, name, email, phone, notes, address):\n        settings = self.settings.get()\n\n        #Changing blank values to None\n        if name == \"\":\n            name = None\n        if email == None:\n            email = [\"\"]\n\n        if name != self.name and name != None:\n            self.name = name\n\n        if email != self.email:\n            self.email = email\n            \n            if settings.mc_use:\n                for e in email:\n                    if e and e != \"\":\n                        settings.mailchimp.add(e, name, False)\n\n        if phone != self.phone:\n            self.phone = phone\n\n        if notes != str(self.notes):\n            if notes == None:\n                notes = \"\"\n            self.notes = notes\n\n        if address != self.address:\n            if address != None and address != \"\" and address != \"None\":\n                #If the address is something and is different than that on file\n                self.address = address\n\n        #And now to put that contact back in the datastore\n        self.put()\n\n    ## -- After Put -- ##\n    @classmethod\n    def _post_put_hook(self, future):\n        e = future.get_result().get()\n        memcache.delete(\"contacts\" + e.settings.urlsafe())\n\n        e.settings.get().refresh.contactsJSON()\n        taskqueue.add(url=\"/tasks/delayindexing\", params={'e' : e.websafe}, queue_name=\"delayindexing\")\n\n    ## -- Before Delete -- ##\n    @classmethod\n    def _pre_delete_hook(cls, key):\n        e = key.get()\n\n        # Delete search index\n        index = search.Index(name=_CONTACT_SEARCH_INDEX)\n        index.delete(e.websafe)\n\nclass DepositReceipt(ndb.Expando):\n    entity_keys = ndb.KeyProperty(repeated=True)\n\n    settings = ndb.KeyProperty()\n    time_deposited = ndb.StringProperty()\n\n    #Sets creation date\n    creation_date = ndb.DateTimeProperty(auto_now_add=True)\n\n    @property\n    def search(self):\n        return tools.DepositSearch(self)\n\n    @property\n    def websafe(self):\n        return self.key.urlsafe()\n\n    ## -- After Put -- ##\n    @classmethod\n    def _post_put_hook(self, future):\n        e = future.get_result().get()\n        taskqueue.add(url=\"/tasks/delayindexing\", params={'e' : e.websafe}, queue_name=\"delayindexing\")\n\n     ## -- Before Delete -- ##\n    @classmethod\n    def _pre_delete_hook(cls, key):\n        e = key.get()\n\n        # Delete search index\n        index = search.Index(name=_DEPOSIT_SEARCH_INDEX)\n        index.delete(e.websafe)\n\nclass Donation(ndb.Expando):\n    contact = ndb.KeyProperty()\n    reviewed = ndb.BooleanProperty(default=False)\n\n    #Only for deposited donations\n    deposited = ndb.BooleanProperty()\n\n    #Determines which account this donation is for - settings key\n    settings = ndb.KeyProperty()\n\n    #How much is this donation worth?\n    amount_donated = DecimalProperty()\n    confirmation_amount = DecimalProperty()\n\n    #Is this a recurring donation\n    isRecurring = ndb.BooleanProperty(default=False)\n\n    #Whether it's recurring, one-time, or offline\n    payment_type = ndb.StringProperty()\n\n    #Special notes from PayPal custom field\n    special_notes = ndb.TextProperty(indexed=True)\n\n    #All recurring donations have the same ID; one-time of course\n    #is unique to that payment\n    payment_id = ndb.StringProperty()\n\n    #Who to associate this donation to (keys)\n    team = ndb.KeyProperty()\n    individual = ndb.KeyProperty()\n    \n    #Sets the time that the donation was placed\n    donation_date = ndb.DateTimeProperty(auto_now_add=True)\n\n    #IPN original data\n    ipn_data = ndb.TextProperty()\n\n    #Used for debugging purposes to see who actually gave the donation\n    given_name = ndb.StringProperty()\n    given_email = ndb.StringProperty()\n\n    @property\n    def address(self):\n        return self.contact.get().address_formatted\n\n    @property\n    def assign(self):\n        return tools.DonationAssign(self)\n\n    @property\n    def confirmation(self):\n        return tools.DonationConfirmation(self)\n\n    @property\n    def contact_url(self):\n        return \"#contact?c=\" + self.contact.urlsafe()\n\n    @property\n    def designated_individual(self):\n        if self.individual:\n            return self.individual.get().name\n        else:\n            return None\n\n    @property\n    def designated_team(self):\n        if self.team:\n            return self.team.get().name\n        else:\n            return None\n\n    @property\n    def email(self):\n        return self.contact.get().email\n\n    @property\n    def formatted_donation_date(self):\n        return tools.convertTime(self.donation_date).strftime(\"%b %d, %Y\")\n\n    @property\n    def name(self):\n        return self.contact.get().name\n\n    @property\n    def review(self):\n        return tools.DonationReview(self)\n\n    @property\n    def search(self):\n        return tools.DonationSearch(self)\n\n    @property\n    def websafe(self):\n        return self.key.urlsafe()\n\n    ## -- Update donation -- ##\n    def update(self, notes, team_key, individual_key, add_deposit, donation_date):\n        #Get self data entity from datastore\n\n        if team_key == \"general\":\n        #If they completely disassociated the self (back to General Fund), clear out team and individual keys\n            self.assign.disassociateTeam(False)\n            self.assign.disassociateIndividual(False)\n\n        else:\n        #The team has isn't general, so associate it\n            self.assign.associateTeam(team_key, False)\n\n            if individual_key == \"none\" or individual_key == None:\n            #Eiither part of General fund or in a team without a specific individual\n                self.assign.disassociateIndividual(False)\n\n            else:\n            #Associate individual\n                self.assign.associateIndividual(individual_key, False)\n                \n        if notes != str(self.special_notes):\n            if notes == None or notes == \"\":\n                notes = \"None\"\n            self.special_notes = notes\n\n        if add_deposit == False:\n            #Make this value none to remove it from deposits window\n            add_deposit = None\n\n        if add_deposit != self.deposited:\n            self.deposited = add_deposit\n\n        if donation_date:\n            self.donation_date = datetime.datetime(donation_date.year, donation_date.month, donation_date.day)\n\n        #And now to put that donation back in the datastore\n        self.put()\n\n    ## -- After Put -- ##\n    @classmethod\n    def _post_put_hook(self, future):\n        e = future.get_result().get()\n        memcache.delete(\"numopen\" + e.settings.urlsafe())\n        memcache.delete(\"owh\" + e.settings.urlsafe())\n\n        if e.team:\n            memcache.delete(\"tdtotal\" + e.team.urlsafe())\n\n        if e.team and e.individual:\n            memcache.delete(\"dtotal\" + e.team.urlsafe() + e.individual.urlsafe())\n            memcache.delete(\"idtotal\" + e.individual.urlsafe())\n            memcache.delete(\"info\" + e.team.urlsafe() + e.individual.urlsafe())\n\n            taskqueue.add(url=\"/tasks/delayindexing\", params={'e' : e.team.urlsafe()}, countdown=2, queue_name=\"delayindexing\")\n            taskqueue.add(url=\"/tasks/delayindexing\", params={'e' : e.individual.urlsafe()}, countdown=2, queue_name=\"delayindexing\")\n\n        taskqueue.add(url=\"/tasks/delayindexing\", params={'e' : e.websafe}, queue_name=\"delayindexing\")\n\n     ## -- Before Delete -- ##\n\n    @classmethod\n    def _pre_delete_hook(cls, key):\n        e = key.get()\n\n        if e.team and e.individual:\n            memcache.delete(\"tdtotal\" + e.team.urlsafe())\n            memcache.delete(\"idtotal\" + e.individual.urlsafe())\n            memcache.delete(\"info\" + e.team.urlsafe() + e.individual.urlsafe())\n\n            taskqueue.add(url=\"/tasks/delayindexing\", params={'e' : e.team.urlsafe()}, countdown=2, queue_name=\"delayindexing\")\n            taskqueue.add(url=\"/tasks/delayindexing\", params={'e' : e.individual.urlsafe()}, countdown=2, queue_name=\"delayindexing\")\n\n        # Delete search index\n        index = search.Index(name=_DONATION_SEARCH_INDEX)\n        index.delete(e.websafe)\n\nclass Impression(ndb.Expando):\n    contact = ndb.KeyProperty()\n    impression = ndb.StringProperty()\n    notes = ndb.TextProperty(indexed=True)\n\n    #Sets creation date\n    creation_date = ndb.DateTimeProperty(auto_now_add=True)\n\n    @property\n    def formatted_creation_date(self):\n        return tools.convertTime(self.creation_date).strftime(\"%b %d, %Y\")\n\n    @property\n    def websafe(self):\n        return self.key.urlsafe()\n\nclass Individual(ndb.Expando):\n    name = ndb.StringProperty()\n    email = ndb.StringProperty()\n\n    #Determines which account this person belongs to\n    settings = ndb.KeyProperty()\n\n    #Credentials\n    admin = ndb.BooleanProperty()\n    password = ndb.StringProperty()\n\n    #Profile\n    description = ndb.TextProperty()\n    photo = ndb.StringProperty()\n\n    #Sets creation date\n    creation_date = ndb.DateTimeProperty(auto_now_add=True)\n\n    @property\n    def data(self):\n        return tools.IndividualData(self)\n\n    @property\n    def teamlist_entities(self):\n        q = TeamList.gql(\"WHERE individual = :i\", i=self.key)\n        return tools.qCache(q)\n\n    @property\n    def search(self):\n        return tools.IndividualSearch(self)\n\n    @property\n    def show_donation_page(self):\n        try:\n            q = TeamList.gql(\"WHERE individual = :i\", i=self.key)\n            return q.fetch(1)[0].show_donation_page\n\n        except:\n            return False\n\n    @property\n    def websafe(self):\n        return self.key.urlsafe()\n\n    ## Currently not in use\n    def email_user(self, msg_id):\n        #Gives the user an email when something happens in their account\n        if msg_id == 1:\n            email_subject\n            email_message = \"A new recurring donation was sent to you!\"\n\n        message = mail.EmailMessage()\n        message.sender = \"donate@globalhopeindia.org\"\n        message.subject = email_subject\n        message.to = self.email\n\n        #Message body here - determined from msg_id\n        message.body = email_message\n\n        logging.info(\"Sending alert email to: \" + self.email)\n\n        #Adding to history\n        logging.info(\"Alert email sent at \" + currentTime())\n\n        message.send()\n\n    ## -- Update Individual -- #\n    def update(self, name, email, team_list, description, change_image, password, show_donation_page):\n        name_changed = False\n\n        if name != self.name:\n            self.name = name\n            name_changed = True\n        \n        if email != self.email:\n            self.email = email\n\n        #Initializes DictDiffer object to tell differences from current dictionary to server-side one\n        team = json.loads(team_list)\n        dd = tools.DictDiffer(team, self.data.team_list)\n\n        for key in dd.added():\n            new_tl = TeamList()\n            new_tl.individual = self.key\n            new_tl.team = tools.getKey(key)\n            new_tl.fundraise_amt = tools.toDecimal(team[key][1])\n\n            new_tl.put()\n\n        for key in dd.removed():\n            query = TeamList.gql(\"WHERE team = :t AND individual = :i\", t=tools.getKey(key), i=self.key)\n            tl = query.fetch(1)[0]\n\n            for d in tl.data.donations:\n                d.team = None\n                d.put()\n\n            tl.key.delete()\n\n        for key in dd.changed():\n            query = TeamList.gql(\"WHERE team = :t AND individual = :i\", t=tools.getKey(key), i=self.key)\n\n            tl = query.fetch(1)[0]\n            tl.fundraise_amt = tools.toDecimal(team[key][1])\n            tl.put()\n\n        if description != str(self.description):\n            self.description = description\n\n        if change_image != None:\n        #If change_image = None, there isn't any change. If it isn't, it \n        #contains a \n            if self.photo != None:\n                #Delete old blob to keep it from orphaning\n                old_blobkey = self.photo\n                old_blob = blobstore.BlobInfo.get(old_blobkey)\n                old_blob.delete()\n\n            self.photo = change_image\n\n        if password != None and password != \"\" and self.password != password:\n            self.password = password\n\n        try:\n            for tl in self.teamlist_entities:\n                if show_donation_page != tl.show_donation_page:\n                    tl.show_donation_page = show_donation_page\n                \n                if name_changed == True:\n                    tl.sort_name = name\n\n                tl.put()\n        except:\n            pass\n\n        self.put()\n\n    ## -- After put -- ##\n    def _post_put_hook(self, future):\n        e = future.get_result().get()\n\n        for t in e.data.teams:\n            memcache.delete(\"teammembers\" + t.team.urlsafe())\n            memcache.delete(\"teammembersdict\" + t.team.urlsafe())\n            memcache.delete(\"info\" + t.team.urlsafe() + e.websafe)\n            \n        taskqueue.add(url=\"/tasks/delayindexing\", params={'e' : e.websafe}, countdown=2, queue_name=\"delayindexing\")\n\n    ## -- Before Delete -- ##\n    @classmethod\n    def _pre_delete_hook(cls, key):\n        i = key.get()\n\n        #Removing this individual's association with donations\n        for d in i.data.donations:\n            d.team = None\n            d.individual = None\n            d.put()\n\n        for tl in i.data.teams:\n            memcache.delete(\"teammembers\" + tl.team.urlsafe())\n            memcache.delete(\"teammembersdict\" + tl.team.urlsafe())\n\n            tl.key.delete()\n\n        # Delete search index\n        index = search.Index(name=_INDIVIDUAL_SEARCH_INDEX)\n        index.delete(i.websafe)\n\nclass Settings(ndb.Expando):\n    name = ndb.StringProperty()\n    email = ndb.StringProperty()\n\n    #Mailchimp values\n    mc_use = ndb.BooleanProperty()\n    mc_apikey = ndb.StringProperty()\n    mc_donorlist = ndb.StringProperty()\n\n    #Impressions\n    impressions = ndb.StringProperty(repeated=True)\n\n    #PayPal\n    paypal_id = ndb.StringProperty()\n\n    #Donate page\n    amount1 = ndb.IntegerProperty()\n    amount2 = ndb.IntegerProperty()\n    amount3 = ndb.IntegerProperty()\n    amount4 = ndb.IntegerProperty()\n    use_custom = ndb.BooleanProperty()\n\n    #Confirmation letters\n    confirmation_text = ndb.TextProperty()\n    confirmation_info = ndb.TextProperty()\n    confirmation_header = ndb.TextProperty()\n    confirmation_footer = ndb.TextProperty()\n    donor_report_text = ndb.TextProperty()\n\n    #Contact JSON\n    contacts_json = ndb.TextProperty()\n\n    #Analytics\n    one_week_history = ndb.TextProperty()\n    one_month_history = ndb.TextProperty()\n\n    #Sets creation date\n    creation_date = ndb.DateTimeProperty(auto_now_add=True)  \n\n    @property\n    def create(self):\n        return tools.SettingsCreate(self)\n\n    @property\n    def data(self):\n        return tools.SettingsData(self)\n\n    @property\n    def exists(self):\n        return tools.SettingsExists(self)\n\n    @property\n    def deposits(self):\n        return tools.SettingsDeposits(self)\n\n    @property\n    def impressions_json(self):\n        return json.dumps(self.impressions)\n\n    @property\n    def mailchimp(self):\n        return tools.SettingsMailchimp(self)\n\n    @property\n    def refresh(self):\n        return tools.SettingsRefresh(self)\n\n    @property\n    def search(self):\n        return tools.SettingsSearch(self)\n\n    ## -- Update -- ##\n    def update(self, name, email, mc_use, mc_apikey, mc_donorlist, paypal_id, impressions, amount1, amount2, amount3, amount4, use_custom, confirmation_header, confirmation_info, confirmation_footer, confirmation_text, donor_report_text):\n        s = self\n\n        if name != s.name:\n            s.name = name\n\n        if email != s.email:\n            s.email = email\n\n        if mc_use != s.mc_use:\n            s.mc_use = mc_use\n\n        if mc_apikey != s.mc_apikey:\n            s.mc_apikey = mc_apikey\n\n        if mc_donorlist != s.mc_donorlist:\n            s.mc_donorlist = mc_donorlist\n\n        if paypal_id != s.paypal_id:\n            s.paypal_id = paypal_id\n\n        if impressions != s.impressions:\n            s.impressions = impressions\n\n        if int(amount1) != s.amount1:\n            s.amount1 = int(amount1)\n\n        if int(amount2) != s.amount2:\n            s.amount2 = int(amount2)\n\n        if int(amount3) != s.amount3:\n            s.amount3 = int(amount3)\n\n        if int(amount4) != s.amount4:\n            s.amount4 = int(amount4)\n\n        if use_custom != s.use_custom:\n            s.use_custom = use_custom\n\n        if confirmation_header != s.confirmation_header:\n            s.confirmation_header = confirmation_header\n\n        if confirmation_info != s.confirmation_info:\n            s.confirmation_info = confirmation_info\n\n        if confirmation_footer != s.confirmation_footer:\n            s.confirmation_footer = confirmation_footer\n\n        if confirmation_text != s.confirmation_text:\n            s.confirmation_text = confirmation_text\n\n        if donor_report_text != s.donor_report_text:\n            s.donor_report_text = donor_report_text\n\n        s.put()\n           \n\n    @property\n    def websafe(self):\n        return self.key.urlsafe()\n\nclass Team(ndb.Expando):\n    name = ndb.StringProperty()\n    settings = ndb.KeyProperty()\n    show_team = ndb.BooleanProperty()\n    \n    #Sets creation date\n    creation_date = ndb.DateTimeProperty(auto_now_add=True)\n\n    @property\n    def data(self):\n        return tools.TeamData(self)\n\n    @property\n    def search(self):\n        return tools.TeamSearch(self)\n\n    @property\n    def websafe(self):\n        return self.key.urlsafe()\n\n    ## -- Update -- ##\n    def update(self, name, show_team):\n        if name != self.name:\n            self.name = name\n\n        if show_team != self.show_team:\n            self.show_team = show_team\n\n        self.put()\n\n    ## -- After put -- ##\n    @classmethod\n    def _post_put_hook(self, future):\n        e = future.get_result().get()\n        memcache.delete('allteams' + e.settings.urlsafe())\n        memcache.delete(\"teammembers\" + e.websafe)\n        memcache.delete(\"teamsdict\" + e.settings.urlsafe())\n\n        taskqueue.add(url=\"/tasks/delayindexing\", params={'e' : e.websafe}, countdown=2, queue_name=\"delayindexing\")      \n\n    ## -- Before Deletion -- ##\n    @classmethod\n    def _pre_delete_hook(cls, key):\n        t = key.get()\n        logging.info(\"Deleting team:\" + t.name)\n\n        for tl in t.data.members:\n            if tl:\n            #Delete this team from all\n                tl.key.delete()\n\n        for d in t.data.donations:\n            d.individual = None\n            d.team = None\n            d.put()\n\n        # Delete search index\n        index = search.Index(name=_TEAM_SEARCH_INDEX)\n        index.delete(t.websafe)\n\nclass TeamList(ndb.Model):\n    individual = ndb.KeyProperty()\n    team = ndb.KeyProperty()\n    fundraise_amt = DecimalProperty()\n\n    #Show in public donation page\n    show_donation_page = ndb.BooleanProperty()\n\n    sort_name = ndb.StringProperty()\n\n    @property\n    def data(self):\n        return tools.TeamListData(self)\n\n    @property\n    def individual_name(self):\n        return self.individual.get().name\n\n    @property \n    def team_name(self):\n        return self.team.get().name\n\n    @property\n    def websafe(self):\n        return self.key.urlsafe()"]],"start1":0,"start2":0,"length1":0,"length2":21109}]],"length":21109}
