{"ts":1363002952250,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"# coding: utf-8\n\nimport logging, json, time, re, math\nfrom time import gmtime, strftime\nfrom datetime import *\nfrom decimal import *\n\n#App Engine platform\nfrom google.appengine.api import taskqueue, mail, memcache, images\nfrom google.appengine.ext.webapp import template\nfrom google.appengine.ext import ndb\nfrom google.appengine.datastore.datastore_query import Cursor\n\n#Mailchimp API\nfrom mailsnake import MailSnake\n\n#Sessions\nfrom gaesessions import get_current_session\n\n#Application files\nimport DataModels as models\n\n#Search\nfrom google.appengine.api import search\n\n_CONTACT_SEARCH_INDEX = \"contact\"\n_DEPOSIT_SEARCH_INDEX = \"deposit\"\n_DONATION_SEARCH_INDEX = \"donation\"\n_INDIVIDUAL_SEARCH_INDEX = \"individual\"\n_TEAM_SEARCH_INDEX = \"team\"\n_NUM_RESULTS = 15\n\n###### ------ Authentication ------ ######\ndef checkCredentials(self, email, password):\n    try:\n        users = models.Individual.gql(\"WHERE email = :e\", e=email)\n        target_user = users.fetch(1)[0]\n\n        if target_user.password == password:\n            return True, target_user\n        else:\n            return False, None\n    except:\n        return False, None\n\ndef checkAuthentication(self, admin_required):\n    try:\n        #If the cookie doesn't exist, send them back to login\n        s_key = getSettingsKey(self)\n        u_key = getUserKey(self)\n\n        u = u_key.get()\n\n        #If the user tries to enter an admin page with standard credentials,\n        #kick them out.\n        if admin_required == True and u.admin == False:\n            logging.info(\"Not authorized - kicking out\")\n            self.redirect(\"/ajax/notauthorized\")\n\n        #Otherwise, good to go\n        return u.admin, s_key.get()\n\n    except Exception, e:\n        logging.info(\"Error in checkAuthentication - kicking out to login page\")\n\n        self.redirect(\"/login\")\n        return None, None\n\ndef getUsername(self):\n    try:\n        user_key = getUserKey(self)\n        user = user_key.get()\n\n        return user.name\n    except:\n        self.redirect(\"/login\")\n\ndef getUserKey(self):\n    self.session = get_current_session()\n    user_key = self.session[\"key\"]\n\n    if user_key == None or user_key == \"\":\n        raise\n\n    return getKey(user_key)\n\ndef getSettingsKey(self):\n    try:\n        user_key = getUserKey(self)\n        user = user_key.get()\n        \n        return user.settings\n    except:\n        self.redirect(\"/login\")\n\ndef RPCcheckAuthentication(self, admin_required):\n    try:\n        self.session = get_current_session()\n\n        #If the cookie doesn't exist, send them back to login\n        if not self.session[\"key\"]:\n            return False\n        else:\n            #The cookie does exist, so store the key\n            user_key = getUserKey(self)\n            user = user_key.get()\n\n            #Get admin privledges associated with this user\n            user_privledges = user.admin\n\n            #If the user tries to enter an admin page with standard credentials,\n            #kick them out.\n            if admin_required == True and user_privledges == False:\n                return \"semi\"\n            \n            #Otherwise, good to go\n            return True\n    except:\n        return False\n\n###### ------ Managing entity access w/memcache ------ ######\n\n# Helper Protobuf entity picklers by Nick Johnson\n# http://blog.notdot.net/2009/9/Efficient-model-memcaching\ndef cache(memcache_key, get_item):\n    item_json = memcache.get(memcache_key)\n\n    if not item_json:\n        item = get_item()\n        memcache.set(memcache_key, json.dumps(item))\n\n    else: \n        item = json.loads(item_json)\n\n    return item\n\ndef deserializeEntity(data):\n    if data is None:\n        return None\n    else:\n        # Getting entity fro protobuf\n        return ndb.model_from_protobuf(data)\n\ndef flushMemcache(self):\n    return memcache.flush_all()\n\ndef getKey(entity_key):\n    return ndb.Key(urlsafe=entity_key)\n\ndef gqlCache(memcache_key, get_item):\n    cached_query = memcache.get(memcache_key)\n\n    if not cached_query:\n        entities = get_item\n\n        serialized = serializeEntities(entities)\n        memcache.set(memcache_key, serialized)\n\n    else: \n        entities = []\n        for e in cached_query:\n            entity = deserializeEntity(e)\n            entities.append(entity)\n\n    return entities\n\ndef gqlCount(gql_object):\n    try:\n        length = len(gql_object)\n    except:\n        length = gql_object.count()\n\n    return length\n\ndef qCache(q):\n    return ndb.get_multi(q.fetch(keys_only=True))\n\ndef serializeEntities(models):\n    if models is None:\n        return None\n    else:\n        entities_list = []\n        for m in models:\n            e_proto = serializeEntity(m)\n            entities_list.append(e_proto)\n\n        return entities_list\n\ndef serializeEntity(model):\n    if model is None:\n        return None\n    else:\n        # Encoding entity to protobuf\n        return ndb.model_to_protobuf(model)\n\n###### ------ Data Access ------ ######\ndef getAccountEmails(self):\n    all_settings = models.Settings.query()\n    all_emails = {}\n\n    for s in all_settings:\n        all_emails[s.email] = str(s.websafe)\n    \n    return all_emails\n\ndef getMailchimpLists(self, mc_apikey):\n    ms = MailSnake(mc_apikey)\n    response = ms.lists()\n\n    try:\n        mc_lists = {}\n\n        for l in response[\"data\"]:\n            list_name = l[\"name\"]\n            list_id = l[\"id\"]\n            mc_lists[list_name] = list_id\n\n        return [True, mc_lists]\n    except:\n        if response[\"code\"] == 104:\n            return [False, \"Sorry, you entered an incorrect Mailchimp API Key\"]\n        else:\n            return [False, \"Unknown error\"]\n\n###### ------ Data Creation ------ ######\ndef newSettings(self, name, email):\n    new_settings = models.Settings()\n    new_settings.name = name\n    new_settings.email = email\n\n    new_settings.mc_use = False\n\n    new_settings.impressions = []\n\n    new_settings.amount1 = 10\n    new_settings.amount2 = 25\n    new_settings.amount3 = 75\n    new_settings.amount4 = 100\n    new_settings.use_custom = True\n\n    logging.info(\"Settings created.\")\n\n    new_settings.put()\n\n    return new_settings.key\n\n###### ------ Utilities ------ ######\ndef currentTime():\n    #Outputs current date and time\n    return convertTime(datetime.utcnow()).strftime(\"%b %d, %Y %I:%M:%S %p\") \n\ndef convertTime(time):\n    utc_zone = UTC()\n    to_zone = EST()\n    time = time.replace(tzinfo=utc_zone)\n\n    new_time = time.astimezone(to_zone)\n    return new_time\n\ndef getWebsafeCursor(cursor_object):\n    if cursor_object:\n        return cursor_object.web_safe_string\n    else:\n        return None\n\ndef getFlash(self):\n    try:\n        self.session = get_current_session()\n        message = self.session[\"flash\"]\n        self.session[\"flash\"] = \"\"\n        if message == None:\n            message = \"\"\n    except:\n        message = \"\"\n\n    return message\n\ndef giveError(self, error_code):\n    checkAuthentication(self, False)\n\n    self.error(error_code)\n    self.response.out.write(\n                   template.render('pages/error.html', {}))\n\ndef getSearchDoc(doc_id, index):\n    if not doc_id:\n        return None\n\n    try:\n        response = index.list_documents(\n        start_doc_id=doc_id, limit=1, include_start_doc=True)\n\n        if response.results and response.results[0].doc_id == doc_id:\n            return response.results[0]\n\n        return None\n\n    except search.InvalidRequest: # catches ill-formed doc ids\n      return None\n\ndef GQLtoDict(self, gql_query):\n    #Converts GQLQuery of App Engine data models to dictionary objects\n    #An empty list to start out with - will be what we return\n    all_objects = []\n\n    for o in gql_query:\n        new_dict = o.to_dict()\n        new_dict[\"key\"] = o.key.urlsafe()\n        all_objects.append(new_dict)\n\n    return all_objects\n\ndef isEmail(email):\n    if email:\n        if re.match(\"^.+\\\\@(\\\\[?)[a-zA-Z0-9\\\\-\\\\.]+\\\\.([a-zA-Z]{2,3}|[0-9]{1,3})(\\\\]?)$\", email) != None:\n            return True\n        else:\n            return False\n    else:\n        return False\n\ndef mergeContacts(c1_key, c2_key):\n    c1 = c1_key.get()\n    c2 = c2_key.get()\n\n    #if contact 2 doesn't have an value and contact 1 does,\n    #replace c2's value with c1's\n\n    if c2.email == \"\" and c1.email != \"\":\n        c2.email = c1.email\n\n    if c2.phone == \"\" and c1.phone != \"\":\n        c2.phone = c1.phone\n\n    if c2.notes == \"\" or c2.notes == \"None\" and c1.notes != \"\":\n        c2.notes = c1.notes\n\n    if c2.address == ['', '', '', ''] and c1.address != ['', '', '', '']:\n        c2.address = c1.address\n\n    #Merge the donations from c1 all to c2\n    for d in c1.data.all_donations:\n        d.contact = c2_key\n        d.put()\n\n    #Save c2\n    c2.put()\n\n    #Finally, delete c1\n    c1.key.delete()\n\ndef moneyAmount(money_string):\n    return \"$\" + str(toDecimal(money_string))\n\ndef queryCursorDB(query, encoded_cursor):\n    new_cursor = None\n    more = None\n\n    if encoded_cursor:\n        query_cursor = Cursor.from_websafe_string(encoded_cursor)\n        entities, cursor, more = query.fetch_page(_NUM_RESULTS, start_cursor=query_cursor)\n    else:\n        entities, cursor, more = query.fetch_page(_NUM_RESULTS)\n\n    if more:\n        new_cursor = cursor.to_websafe_string()\n    else:\n        new_cursor = None\n\n    return [entities, new_cursor]\n\ndef searchReturnAll(query, search_results, settings, search_function, entity_return=True):\n    total_results = search_results.number_found\n    num_cursors_needed = int(math.ceil(float(total_results) / float(_NUM_RESULTS)))\n\n    all_results = []\n    results = search_results\n    \n    for x in range(0, num_cursors_needed):\n        if entity_return == True:\n            all_results += searchToEntities(results)\n\n        else:\n            all_results.extend(searchToDocuments(results))\n\n        query_cursor = search_results.cursor\n        results = search_function(query, query_cursor=query_cursor, entity_return=entity_return)[0]\n\n    return all_results\n\ndef searchToDocuments(search_results):\n    documents = []\n\n    for r in search_results:\n        documents.append(r)\n\n    return documents\n\ndef searchToEntities(search_results):\n    entities = []\n\n    for r in search_results:\n        key = r.fields[0].value\n        d = getKey(key).get()\n        entities.append(d)\n\n    return entities\n\ndef setFlash(self, message):\n    self.session = get_current_session()\n    self.session[\"flash\"] = message\n\ndef strArrayToKey(self, str_array):\n    key_array = []\n    for k in str_array:\n        key_array.append(getKey(k))\n\n    return key_array\n\ndef toDecimal(number):\n    if number != None:\n        #Stripping amount donated from commas, etc\n        non_decimal = re.compile(r'[^\\d.]+')\n        number = non_decimal.sub('', str(number))\n\n        return Decimal(number).quantize(Decimal(\"1.00\"))\n    else:\n        return Decimal(0).quantize(Decimal(\"1.00\"))\n\n###### ------ Utilities Classes ------ ######\nclass UtilitiesBase():\n    def __init__(self, base_entity):\n        #Property self.e is an alias back to the original entity\n        self.e = base_entity\n\n## -- Settings Classes -- ##\nclass SettingsCreate(UtilitiesBase):\n    def contact(self, name, email, phone, address, notes, add_mc):\n        logging.info(\"Creating contact for: \" + name)\n        if name:\n            new_contact = models.Contact()\n            new_contact.name = name\n            new_contact.settings = self.e.key\n\n            if address == None or address == \"\":\n                address = ['', '', '', '']\n            if notes == None or notes == \"None\":\n                notes = \"\"\n            if email == None or email == \"None\":\n                email = \"\"\n            if phone == None or phone == \"None\":\n                phone = \"\"\n\n            new_contact.email = email\n            new_contact.phone = phone\n            new_contact.address = address\n            new_contact.notes = notes\n\n            #Log the contact\n            logging.info(\"Contact created.\")\n\n            new_contact.put()\n\n            if add_mc == True and email:\n                #Add new contact to Mailchimp\n                self.e.mailchimp.add(email, name, False)\n\n            return new_contact.key\n        else:\n            logging.error(\"Cannot create contact because there is not a name.\")\n\n    def deposit_receipt(self, entity_keys):\n        new_deposit = models.DepositReceipt()\n\n        new_deposit.entity_keys = entity_keys\n        new_deposit.settings = self.e.key\n        new_deposit.time_deposited = currentTime()\n\n        new_deposit.put()\n\n    def donation(self, name, email, amount_donated, confirmation_amount, address, team_key, individual_key, add_deposit, payment_id, special_notes, payment_type, email_subscr, ipn_data):\n        #All variables being passed as either string or integer\n        new_donation = models.Donation()\n        new_donation.settings = self.e.key\n        new_donation.payment_id = payment_id\n        new_donation.payment_type = payment_type\n        new_donation.special_notes = special_notes\n        new_donation.ipn_data = ipn_data\n\n        new_donation.given_name = name\n        new_donation.given_email = email\n\n        contact_key = None\n\n        def write_contact(query):\n            c = query.fetch(1)[0]\n            new_donation.contact = c.key\n\n            c.update(name, email, None, None, address)\n            return c.key\n\n        query = models.Contact.gql(\"WHERE settings = :s AND email = :e\", s=self.e.key, e=email)\n        query2 = models.Contact.gql(\"WHERE settings = :s AND name = :n\", s=self.e.key, n=name)\n\n        if gqlCount(query) != 0 and email:\n            contact_key = write_contact(query)\n\n        elif gqlCount(query2) != 0:\n            contact_key = write_contact(query2)\n\n        else:\n            #Add new contact\n            c_key = self.contact(name, email, None, address, None, email_subscr)\n            new_donation.contact = c_key\n            contact_key = c_key\n\n        if payment_type == \"recurring\":\n            new_donation.isRecurring = True\n\n        new_donation.amount_donated = toDecimal(amount_donated)\n        new_donation.confirmation_amount = toDecimal(confirmation_amount)\n\n        if add_deposit == True:\n            logging.info(\"Adding to undeposited donations.\")\n            new_donation.deposited = False\n        else:\n            logging.info(\"Not adding to undeposited donations\")\n            new_donation.deposited = True\n\n        if team_key == \"\" or team_key == \"none\":\n            team_key = None \n            \n        if individual_key == \"\" or individual_key == \"none\":\n            individual_key = None\n\n        new_donation.team = team_key\n        new_donation.individual = individual_key\n            \n        new_donation.put()\n\n        # If designated, re-index team and individual\n        if team_key:\n            taskqueue.add(url=\"/tasks/delayindexing\", params={'e' : team_key.urlsafe()}, countdown=5, queue_name=\"delayindexing\")\n\n        if individual_key:\n            taskqueue.add(url=\"/tasks/delayindexing\", params={'e' : individual_key.urlsafe()}, countdown=5, queue_name=\"delayindexing\")\n\n\n        if payment_type != \"offline\":\n\n            if special_notes != \"\" and special_notes != None:\n                email = mail.EmailMessage()\n                email.sender = \"GHI Donations <mailer@ghidonations.appspotmail.com>\"\n                email.subject = \"New Donation with Note\"\n                email.to = self.e.email\n\n                message = \"\"\"\nA new note was received from {name} for ${confirmation_amount} ({payment_type} donation): <br>\n\n<strong>{special_notes}</strong> <br><br>\n\nYou can view this donation at <a href=\"https://ghidonations.appspot.com/#contact?c={contact_key}\">https://ghidonations.appspot.com/contact?c={contact_key}</a>.<br><br>\nThanks!\"\"\"\n\n                message = message.format(payment_type=payment_type, name=name, confirmation_amount=confirmation_amount, special_notes=special_notes, contact_key=contact_key.urlsafe())\n\n                email.html = message\n                email.send()\n\n            #Go ahead and send the confirmation email automatically\n            new_donation.confirmation.task(86400)\n            new_donation.review.archive()\n\n        return new_donation.key\n\n    def individual(self, name, team_key, email, password, admin):\n        new_individual = models.Individual()\n\n        new_individual.name = name\n        new_individual.email = email\n        new_individual.settings = self.e.key\n        new_individual.password = password\n        new_individual.admin = bool(admin)\n        new_individual.description = \"Thank you for supporting my short-term mission trip to India. Your prayer and financial support is greatly needed and appreciated. Thanks for helping make it possible for me to go join God in His work in India.\"\n\n        new_individual.put()\n\n        new_tl = models.TeamList()\n        new_tl.individual = new_individual.key\n        new_tl.team = team_key\n        new_tl.fundraise_amt = toDecimal(\"2700\")\n        new_tl.sort_name = name\n        new_tl.show_donation_page = True\n\n        new_tl.put()\n\n        memcache.delete(\"teammembersdict\" + team_key.urlsafe())\n\n        logging.info(\"Individual created.\")\n        return new_individual.key\n\n    def recurring_donation(self, payment_id, duration, ipn_data):\n        new_recurring = models.show_donation_page()\n        new_recurring.payment_id = payment_id\n        new_recurring.duration = duration\n        new_recurring.ipn_data = ipn_data\n\n        new_recurring.put()\n\n    def team(self, name):\n        new_team = models.Team()\n        new_team.name = name\n        new_team.settings = self.e.key\n        new_team.show_team = True\n\n        logging.info(\"Team created.\")\n\n        new_team.put()\n\n        return new_team.key\n\n        return new_donation.key.urlsafe()\n        \nclass SettingsData(UtilitiesBase):\n    @property\n    def all_contacts(self):\n        q = models.Contact.gql(\"WHERE settings = :s ORDER BY name\", s=self.e.key)\n        return q\n\n    @property\n    def all_deposits(self):\n        q = models.DepositReceipt.gql(\"WHERE settings = :s ORDER BY creation_date DESC\", s=self.e.key)\n        return q\n\n    @property\n    def all_donations(self):\n        q = models.Donation.gql(\"WHERE settings = :s ORDER BY donation_date DESC\", s=self.e.key)\n        return q\n\n    @property\n    def all_individuals(self):\n        q = models.Individual.gql(\"WHERE settings = :k ORDER BY name ASC\", k=self.e.key)\n        return q\n\n    @property\n    def all_teams(self):\n        q = models.Team.gql(\"WHERE settings = :k ORDER BY name\", k=self.e.key)\n        return q\n\n    def contacts(self, query_cursor):\n        query = self.all_contacts\n        return queryCursorDB(query, query_cursor)\n\n    def deposits(self, query_cursor):\n        query = self.all_deposits\n        return queryCursorDB(query, query_cursor)\n\n    @property\n    def display_teams(self):\n        q = models.Team.gql(\"WHERE settings = :k AND show_team = True ORDER BY name\", k=self.e.key)\n        return q\n\n    def donations(self, query_cursor):\n        query = self.all_donations\n        return queryCursorDB(query, query_cursor)\n\n    def individuals(self, query_cursor):\n        query = self.all_individuals\n        return queryCursorDB(query, query_cursor)\n\n    @property\n    def num_open_donations(self):\n        memcache_key = \"numopen\" + self.e.websafe\n\n        def get_item():\n            query = models.Donation.gql(\"WHERE reviewed = :c AND settings = :s ORDER BY donation_date DESC\", c=False, s=self.e.key)\n            return gqlCount(query)\n\n        return cache(memcache_key, get_item)\n\n    def open_donations(self, query_cursor):\n        query = models.Donation.gql(\"WHERE reviewed = :c AND settings = :s ORDER BY donation_date DESC\", c=False, s=self.e.key)\n        return queryCursorDB(query, query_cursor)\n\n    @property\n    def recurring_donors(self):\n        donors_dict = {}\n        query = models.Donation.gql(\"WHERE settings = :s AND isRecurring = :r\", s=self.e.key, r=True)\n\n        for d in query:\n            #Adding to dictionary first to manage duplicates\n            websafe = d.contact\n\n            if not websafe in donors_dict:\n                donors_dict[websafe] = d.contact.get()\n\n        donors = []\n        for k in donors_dict:\n            #Now creating a normal iterable array of just entities\n            donors.append(donors_dict[k])\n\n        return donors\n\n    def recurring_info(self, payment_id):\n        info = models.show_donation_page.gql(\"WHERE payment_id = :id\", id=payment_id).fetch(1)[0]\n        return info\n\n    def team_donors(self, team_key):\n        donors = []\n        donations = models.Donation.gql(\"WHERE team = :t\", t=team_key)\n        for d in donations:\n            #if d.name not in donors:\n            donors.append(d.contact.get())\n            \n        return donors\n\n    @property\n    def teams_dict(self):\n        memcache_key = \"teamsdict\" + self.e.websafe\n\n        def get_item():\n            teams = models.Team.gql(\"WHERE settings = :k AND show_team = :s\", k=self.e.key, s=True)\n\n            teams_dict = {}\n            for t in teams:\n                teams_dict[t.name] = t.websafe\n\n            return teams_dict\n\n        return cache(memcache_key, get_item)\n\n    @property\n    def teams_list(self):\n        teams = []\n        for t in self.teams:\n            teams.append(t)\n        return teams\n        \n    def teams(self, query_cursor):\n        query = self.all_teams\n        return queryCursorDB(query, query_cursor)\n\n    @property\n    def undeposited_donations(self):\n        q = models.Donation.gql(\"WHERE settings = :s AND deposited = :d ORDER BY donation_date DESC\", s=self.e.key, d=False)\n        return qCache(q)\n\n    ## -- Contact autocomplete -- ##\n    @property\n    def contactsJSON(self):\n        memcache_key = \"contacts\" + self.e.websafe\n\n        def get_item():\n            return json.loads(self.e.contacts_json)\n\n        return cache(memcache_key, get_item)\n\n    ## -- Analytics -- ##\n    @property\n    def one_week_history(self):\n        memcache_key = \"owh\" + self.e.websafe\n\n        def get_item():\n            last_week = datetime.today() - timedelta(days=7)\n\n            #Get donations made in the last week\n            donations = models.Donation.gql(\"WHERE settings = :s AND donation_date > :last_week ORDER BY donation_date DESC\", \n                        s=self.e.key, last_week=last_week)\n\n            donation_count = 0\n            total_money = toDecimal(0)\n\n            for d in donations:\n                #Counting total money\n                total_money += d.amount_donated\n                \n                #Counting number of donations\n                donation_count += 1\n\n            return [donation_count, str(total_money)]\n\n        return cache(memcache_key, get_item)\n\nclass SettingsDeposits(UtilitiesBase):\n    def deposit(self, unicode_keys):\n        #Changing all unicode keys into Key objects\n        donation_keys = []\n        for key in unicode_keys:\n            donation_keys.append(getKey(key))\n\n        for key in donation_keys:\n            d = key.get()\n            d.deposited = True\n            d.put()\n\n        self.e.create.deposit_receipt(donation_keys)\n\n    def remove(self, donation_keys):\n        for key in donation_keys:\n            d = key.get()\n            d.deposited = None\n            d.put()\n\nclass SettingsExists(UtilitiesBase):\n    ## -- Check existences -- ##\n    def contact(self, name):\n        #Check if a user exists in the database - when creating new users\n        try:\n            #Try checking by name \n            user = models.Contact.gql(\"WHERE settings = :s AND name = :n\", s=self.e.key, n=name)\n\n            if user.fetch(1)[0]:\n                return [True, user[0]]\n            else:\n                return [False, None]\n\n        except:\n            return [False, None]\n\n    def entity(self, key):\n        exists = True\n        try:\n            key.get()\n        except:\n            exists = False\n\n        return exists\n\n    def individual(self, email):\n        #Check if a user exists in the database - when creating new users\n        try:\n            user = models.Individual.gql(\"WHERE settings = :s AND email = :e\", s=self.e.key, e=email)\n\n            if user.fetch(1)[0]:\n                return [True, user[0]]\n            else:\n                return [False, None]\n\n        except:\n            return [False, None]\n\nclass SettingsMailchimp(UtilitiesBase):\n    def add(self, email, name, task_queue):\n        if self.e.mc_use == True:\n        #Check if the settings indicate to use Mailchimp\n\n            if isEmail(email):\n                ms = MailSnake(self.e.mc_apikey)\n                try:               \n                    #[ MailChimp API v1.3 documentation ]\n                    #http://www.mailchimp.com/api/1.3/\n                    \n                    #http://apidocs.mailchimp.com/api/1.3/listsubscribe.func.php\n                    #listSubscribe(string apikey, string id, string email_address, array merge_vars, string email_type, \n                    #bool double_optin, bool update_existing, bool replace_interests, bool send_welcome)\n                    name_split = name.split()\n                    merge_vars = {\"FNAME\":name_split[0], \"LNAME\":\" \".join(name_split[1:])}\n\n                    response = ms.listSubscribe(id=self.e.mc_donorlist, email_address=email, merge_vars=merge_vars)\n\n                    logging.info(\"Mailchimp response: \" + str(response))\n\n                    if response == True:\n                        logging.info(\"Email address added to database.\")\n\n                    elif response[\"code\"] == 214:\n                        logging.info(\"Already in database. No action required.\")\n                    \n                    else:\n                    #Must be an error if not True and not error 214 - raise error\n                        raise\n\n                except:\n                    if task_queue == False:\n                    #This is the original request, so add to task queue.\n                        logging.error(\"An error occured contacting Mailchimp. Added to task queue to try again.\")\n                        taskqueue.add(url=\"/tasks/mailchimp\", params={'email' : email, 'name' : name, 'settings' : self.e.websafe})\n                        \n                    else:\n                    #If this is coming from the task queue, fail it (so the task queue retry mechanism works)\n                        raise\n                        logging.info(\"Request from task queue failed. Sending back 500 error.\")\n\n            else:\n                logging.info(\"Not a valid email address. Not continuing.\")\n\nclass SettingsSearch(UtilitiesBase):\n    def search(self, index_name, expr_list, query, search_function, query_cursor=None, entity_return=False, return_all=False):\n        # query string looks like 'job tag:\"very important\" sent < 2011-02-28'\n\n        if query_cursor == None:\n            query_cursor = search.Cursor()\n        elif isinstance(query_cursor, (str, unicode)):\n            query_cursor = search.Cursor(web_safe_string=query_cursor)\n\n        # construct the sort options\n        sort_opts = search.SortOptions(expressions=expr_list)\n\n        query_options = search.QueryOptions(\n            cursor=query_cursor,\n            limit=_NUM_RESULTS,\n            sort_options=sort_opts)\n\n        # Adding settings key to query (AND is mandatory to ensure that you cannot access other organizations' data)\n        add_settings_query = \" settings:\" + self.e.websafe\n        if query == \"\":\n            query += add_settings_query\n\n        elif add_settings_query not in query:\n            query += \" AND\" + add_settings_query  \n\n        query_obj = search.Query(query_string=query, options=query_options)\n\n        search_results = search.Index(name=index_name).search(query=query_obj)\n\n        if entity_return == True and return_all == False:\n            new_cursor = None\n            if search_results.cursor != None:\n                new_cursor = search_results.cursor.web_safe_string\n\n            return [searchToEntities(search_results), new_cursor]\n\n        elif return_all == True:\n            return searchReturnAll(query, search_results, settings=self.e, search_function=search_function, entity_return=entity_return)\n\n        else:\n            return [search_results, search_results.cursor]\n\n    def contact(self, query, **kwargs):\n        expr_list = [search.SortExpression(\n            expression=\"name\", default_value='',\n            direction=search.SortExpression.ASCENDING)]\n\n        search_function = self.e.search.contact\n\n        return self.search(index_name=_CONTACT_SEARCH_INDEX, expr_list=expr_list, query=query, search_function=search_function, **kwargs)\n\n    def deposit(self, query, **kwargs):\n        default_date = datetime(2012,1,1)\n\n        expr_list = [search.SortExpression(\n            expression=\"created\", default_value=default_date,\n            direction=search.SortExpression.DESCENDING)]\n\n        search_function = self.e.search.deposit\n\n        return self.search(index_name=_DEPOSIT_SEARCH_INDEX, expr_list=expr_list, query=query, search_function=search_function, **kwargs)\n\n    def donation(self, query, **kwargs):\n        default_date = datetime(2012,1,1)\n\n        expr_list = [search.SortExpression(\n            expression=\"time\", default_value=default_date,\n            direction=search.SortExpression.DESCENDING)]\n\n        search_function = self.e.search.donation\n\n        return self.search(index_name=_DONATION_SEARCH_INDEX, expr_list=expr_list, query=query, search_function=search_function, **kwargs)\n\n    def individual(self, query, **kwargs):\n        expr_list = [search.SortExpression(\n            expression=\"name\", default_value='',\n            direction=search.SortExpression.ASCENDING)]\n\n        search_function = self.e.search.individual\n\n        return self.search(index_name=_INDIVIDUAL_SEARCH_INDEX, expr_list=expr_list, query=query, search_function=search_function, **kwargs)\n\n    def team(self, query, **kwargs):\n        expr_list = [search.SortExpression(\n            expression=\"name\", default_value='',\n            direction=search.SortExpression.ASCENDING)]\n\n        search_function = self.e.search.team\n\n        return self.search(index_name=_TEAM_SEARCH_INDEX, expr_list=expr_list, query=query, search_function=search_function, **kwargs)\n\n## -- Contact Classes -- ##\nclass ContactCreate(UtilitiesBase):\n    def impression(self, impression, notes):\n        new_impression = models.Impression()\n\n        new_impression.contact = self.e.key\n        new_impression.impression = impression\n        new_impression.notes = notes\n\n        new_impression.put()\n\nclass ContactData(UtilitiesBase):\n    @property\n    def all_donations(self):\n        q = models.Donation.gql(\"WHERE settings = :s AND contact = :c ORDER BY donation_date DESC\", s=self.e.settings, c=self.e.key)\n        return q\n\n    @property \n    def all_impressions(self):\n        q = models.Impression.gql(\"WHERE contact = :c ORDER BY creation_date DESC\", c=self.e.key)\n        return q\n\n    def donations(self, query_cursor):\n        query = self.all_donations\n        return queryCursorDB(query, query_cursor)\n\n    def annual_donations(self, year):\n        year = int(year)\n        year_start = datetime(year, 1, 1)\n        year_end = datetime(year, 12, 31)\n\n        return models.Donation.gql(\"WHERE contact = :c AND donation_date >= :year_start AND donation_date <= :year_end ORDER BY donation_date ASC\", c=self.e.key, year_start=year_start, year_end=year_end)\n\n    @property\n    def recurring_donation_total(self):\n        donation_total = toDecimal(0)\n\n        query = models.Donation.gql(\"WHERE contact = :c AND isRecurring = :r\", c=self.e.key, r=True)\n        for d in query:\n            donation_total += d.amount_donated\n\n        return donation_total\n\n    def impressions(self, query_cursor):\n        query = self.all_impressions\n        return queryCursorDB(query, query_cursor)\n\nclass ContactSearch(UtilitiesBase):\n    def createDocument(self):\n        c = self.e\n\n        city = c.address[1]\n        state = c.address[2]\n\n        total_donated = toDecimal(0)\n        number_donations = 0\n        for d in c.data.all_donations:\n            total_donated += d.confirmation_amount\n            number_donations += 1\n\n        document = search.Document(doc_id=c.websafe,\n            fields=[search.TextField(name='contact_key', value=c.websafe),\n                    search.TextField(name='name', value=c.name),\n                    search.TextField(name='email', value=c.email),\n                    search.NumberField(name='total_donated', value=float(total_donated)),\n                    search.NumberField(name='number_donations', value=int(number_donations)),\n                    search.TextField(name='phone', value=c.phone),\n                    search.TextField(name='city', value=city),\n                    search.TextField(name='state', value=state),\n                    search.DateField(name='created', value=c.creation_date),\n                    search.TextField(name='settings', value=c.settings.urlsafe()),\n                    ])\n\n        return document\n\n    def index(self):\n        # Updates search index of this entity or creates new one if it doesn't exist\n        index = search.Index(name=_CONTACT_SEARCH_INDEX)\n\n        # Creating the new index\n        try:\n            doc = self.createDocument()\n            index.put(doc)\n        except:\n            logging.error(\"Failed creating index on contact key:\" + self.e.websafe)\n\n## -- Deposit Classes -- ##\nclass DepositSearch(UtilitiesBase):\n    def createDocument(self):\n        de = self.e\n\n        document = search.Document(doc_id=de.websafe,\n            fields=[search.TextField(name='deposit_key', value=de.websafe),\n                    search.TextField(name='time_deposited_string', value=de.time_deposited),\n                    search.DateField(name='created', value=de.creation_date),\n                    search.TextField(name='settings', value=de.settings.urlsafe()),\n                    ])\n\n        return document\n\n    def index(self):\n        # Updates search index of this entity or creates new one if it doesn't exist\n        index = search.Index(name=_DEPOSIT_SEARCH_INDEX)\n\n        # Creating the new index\n        try:\n            doc = self.createDocument()\n            index.put(doc)\n        except:\n            logging.error(\"Failed creating index on deposit key:\" + self.e.websafe)\n\n## -- Donation Classes -- ##\nclass DonationAssign(UtilitiesBase):\n    ## -- Associating Donations With Team/Individual -- ##\n    def associateIndividual(self, individual_key, writeback):\n        if self.e.individual != individual_key:\n        #Just to make sure the association is actually changed - instead of marking the same value as it was before\n            try:\n                message = \"Donation \" + self.e.websafe +  \" associated with individual\" + str(individual_key.urlsafe()) + \".\"\n                logging.info(message)\n            except:\n                pass\n\n            self.e.individual = individual_key\n\n        if writeback == True:\n            self.e.put()\n\n    def associateTeam(self, team_key, writeback):\n        if self.e.team != team_key:\n        #Just to make sure the association is actually changed - instead of marking the same value as it was before\n            try:\n                message = \"Donation \" + self.e.websafe +  \" associated with team\" + str(team_key.urlsafe()) + \".\"\n                logging.info(message)\n            except:\n                pass\n\n            self.e.team = team_key\n\n        if writeback == True:\n            self.e.put()\n\n    def disassociateIndividual(self, writeback):\n        if self.e.individual != None:\n        #Just to make sure the association is actually changed - instead of marking the same value as it was before\n            message = \"Donation \" + self.e.websafe +  \" removed from individual\" + str(self.e.individual.urlsafe()) + \".\"\n            logging.info(message)\n\n            self.e.individual = None\n\n        if writeback == True:\n            self.e.put()\n\n    def disassociateTeam(self, writeback):\n        if self.e.team != None:\n        #Just to make sure the association is actually changed - instead of marking the same value as it was before\n            message = \"Donation \" + self.e.websafe +  \" removed from team\" + str(self.e.team.urlsafe()) + \".\"\n            logging.info(message)\n\n            self.e.team = None\n\n        if writeback == True:\n            self.e.put()\n\nclass DonationConfirmation(UtilitiesBase):\n    ## -- Confirmation Letter -- ##\n    def email(self):\n        d = self.e\n\n        message = mail.EmailMessage()\n        message.to = d.email\n\n        ## TODO - is there any other way to get an organization's email address to appear if it's not verified?\n        settings_name = d.settings.get().name\n        if settings_name == \"GHI\":\n            message.sender = \"donate@globalhopeindia.org\"\n            message.subject = \"Thanks for your donation!\"\n        else:\n            message.sender = \"mailer@ghidonations.appspotmail.com\"\n            message.subject = settings_name + \" - Thanks for your donation!\"\n\n        date = convertTime(d.donation_date).strftime(\"%B %d, %Y\")\n        s = d.settings.get()\n\n        if d.individual:\n            individual_name = d.individual.get().name\n        elif d.team:\n            individual_name = d.team.get().name\n        else:\n            individual_name = None\n\n        template_variables = {\"s\": s, \"d\" : d, \"date\" : date, \"individual_name\" : individual_name}\n\n        who = \"http://ghidonations.appspot.com\"\n\n        template_variables[\"see_url\"] = d.confirmation.see_url(who)\n        template_variables[\"print_url\"] = d.confirmation.print_url(who)\n \n        #Message body/HTML here\n        message.html = template.render(\"pages/letters/thanks_email.html\", template_variables)\n\n        logging.info(\"Sending confirmation email to: \" + d.email)\n\n        #Adding to history\n        logging.info(\"Confirmation email sent at \" + currentTime())\n\n        message.send()\n\n    def print_url(self, who):\n        if not who:\n            who = \"\"\n\n        return who + \"/thanks?m=p&id=\" + self.e.websafe\n\n    def see_url(self, who):\n        if not who:\n            who = \"\"\n\n        return who + \"/thanks?m=w&id=\" + self.e.websafe\n\n    def task(self, countdown_secs):\n        logging.info(\"Tasking confirmation email.  Delaying for \" + str(countdown_secs) + \" seconds.\")\n        taskqueue.add(url=\"/tasks/confirmation\", params={'donation_key' : self.e.websafe}, countdown=int(countdown_secs))\n\nclass DonationData(UtilitiesBase):\n    @property\n    def individual_name(self):\n        if self.e.individual != None:\n            return self.e.individual.get().name\n        else:\n            return None\n\n    @property\n    def team_name(self):\n        if self.e.team != None:\n            return self.e.team.get().name\n        else:\n            return None\n\nclass DonationReview(UtilitiesBase):\n    ## -- Review Queue -- ##\n    def archive(self):\n        self.e.reviewed = True\n        self.e.put()\n\n    def markUnreviewed(self):\n        self.e.reviewed = False\n        self.e.put()\n\nclass DonationSearch(UtilitiesBase):\n    def createDocument(self):\n        d = self.e\n\n        reviewed = \"no\"\n        if d.reviewed == True:\n            reviewed = \"yes\"\n\n        individual_key = \"\"\n        if d.individual:\n            individual_key = d.individual.urlsafe()\n\n        document = search.Document(doc_id=d.websafe,\n            fields=[search.TextField(name='donation_key', value=d.websafe),\n                    search.DateField(name='time', value=d.donation_date),\n                    search.TextField(name='name', value=d.contact.get().name),\n                    search.TextField(name='email', value=d.contact.get().email),\n                    search.NumberField(name='amount', value=float(d.amount_donated)),\n                    search.TextField(name='type', value=d.payment_type),\n                    search.TextField(name='team', value=d.designated_team),\n                    search.TextField(name='individual', value=d.designated_individual),\n                    search.TextField(name='reviewed', value=reviewed),\n                    search.TextField(name='formatted_donation_date', value=d.formatted_donation_date),\n                    search.TextField(name='contact_key', value=d.contact.urlsafe()),\n                    search.TextField(name='individual_key', value=individual_key),\n                    search.TextField(name='settings', value=d.settings.urlsafe()),\n                    ])\n\n        return document\n\n    def index(self):\n        # Updates search index of this entity or creates new one if it doesn't exist\n        index = search.Index(name=_DONATION_SEARCH_INDEX)\n\n        # Creating the new index\n        try:\n            doc = self.createDocument()\n            index.put(doc)\n        except Exception as e:\n            logging.error(\"Failed creating index on donation key:\" + self.e.websafe + \" because: \" + str(e))\n\n## -- Individual Classes -- ##\nclass IndividualData(UtilitiesBase):\n    @property\n    def donation_total(self):\n        memcache_key = \"idtotal\" + self.e.websafe\n\n        def get_item():\n            settings = self.e.settings\n            individual_key = self.e.key\n\n            q = models.Donation.gql(\"WHERE settings = :s AND individual = :i\", s=settings, i=individual_key)\n            donations = qCache(q)\n\n            donation_total = toDecimal(0)\n\n            for d in donations:\n                donation_total += d.amount_donated\n\n            return str(donation_total)\n\n        item = cache(memcache_key, get_item)\n        return toDecimal(item)\n\n    @property\n    def donations(self):\n        q = models.Donation.gql(\"WHERE individual = :i ORDER BY donation_date DESC\", i=self.e.key)\n        return qCache(q)\n\n    def getTeamList(self, team):\n        query = models.TeamList.gql(\"WHERE individual = :i AND team = :t\", i=self.e.key, t=team)\n        return query.fetch(1)[0]\n\n    def info(self, team):\n        memcache_key = \"info\" + team.urlsafe() + self.e.websafe\n        def get_item():\n            if self.e.photo:\n                image_url = images.get_serving_url(self.e.photo, 150)\n            else:\n                image_url = \"https://ghidonations.appspot.com/images/face150.jpg\"\n\n            tl = self.getTeamList(team)\n            percentage = int(float(tl.donation_total / tl.fundraise_amt) * 100)\n\n            if percentage > 100:\n                percentage = 100\n            elif percentage <0:\n                percentage = 0\n\n            message = str(percentage) + \"% to goal of $\" + str(tl.fundraise_amt)\n                \n            return [image_url, self.e.name, self.e.description, percentage, message]\n\n        return cache(memcache_key, get_item)\n\n    @property\n    def photo_url(self):\n        if self.e.photo != None:\n            try:\n                photo = images.get_serving_url(self.e.photo, 200, secure_url=True)\n            except:\n                photo = \"/images/face.jpg\"\n        else:\n            photo = \"/images/face.jpg\"\n\n        return photo\n\n    @property\n    def search_team_list(self):\n        search_list = \"\"\n\n        for tl in self.teams:\n            search_list += \" \" + tl.team.urlsafe()\n\n        return search_list\n\n    @property\n    def teams(self):\n        q = models.TeamList.gql(\"WHERE individual = :i\", i=self.e.key)\n        return q\n\n    @property\n    def team_list(self):\n        teams_dict = {}\n\n        for tl in self.teams:\n            array = [tl.team.get().name, str(tl.fundraise_amt)]\n            teams_dict[tl.team.urlsafe()] = array\n\n        return teams_dict\n\n    @property\n    def team_json(self):\n        return json.dumps(self.team_list)\n\nclass IndividualSearch(UtilitiesBase):\n    def createDocument(self):\n        i = self.e\n\n        team_names = \"\"\n        raised = toDecimal(0)\n\n        tl_list = i.teamlist_entities\n        for tl in tl_list:\n            team_names += tl.team_name + \", \"\n            raised += tl.donation_total\n\n        document = search.Document(doc_id=i.websafe,\n            fields=[search.TextField(name='individual_key', value=i.websafe),\n                    search.TextField(name='name', value=i.name),\n                    search.TextField(name='email', value=i.email),\n                    search.TextField(name='team', value=team_names),\n                    search.NumberField(name='raised', value=float(raised)),\n                    search.DateField(name='created', value=i.creation_date),\n                    search.TextField(name='team_key', value=i.data.search_team_list),\n                    search.TextField(name='settings', value=i.settings.urlsafe()),\n                    ])\n\n        return document\n\n    def index(self):\n        # Updates search index of this entity or creates new one if it doesn't exist\n        index = search.Index(name=_INDIVIDUAL_SEARCH_INDEX)\n    \n        # Creating the new index\n        try:\n            doc = self.createDocument()\n            index.put(doc)\n        except:\n            logging.error(\"Failed creating index on individual key:\" + self.e.websafe)\n\n## -- Team Classes -- ##\nclass TeamData(UtilitiesBase):\n    @property\n    def donations(self):\n        q = models.Donation.gql(\"WHERE settings = :s AND team = :t ORDER BY donation_date\", s=self.e.settings, t=self.e.key)\n        return qCache(q)\n\n    @property\n    def donation_total(self):\n        team_key = self.e.key\n        memcache_key = \"tdtotal\" +  team_key.urlsafe()\n        \n        def get_item():\n            settings = self.e.settings\n\n            q = models.Donation.gql(\"WHERE settings = :s AND team = :t\", s=settings, t=team_key)\n            donations = qCache(q)\n\n            donation_total = toDecimal(0)\n\n            for d in donations:\n                donation_total += d.amount_donated\n\n            return str(donation_total)\n\n        item = cache(memcache_key, get_item) \n        return toDecimal(item)\n\n    @property\n    def members(self):\n        q = models.TeamList.gql(\"WHERE team = :t ORDER BY sort_name\", t=self.e.key)\n        return qCache(q)\n\n    @property\n    def members_public_donation_page(self):\n        #Returns members that indicated that they want to be included\n        #in the public donation page\n        q = models.TeamList.gql(\"WHERE team = :t AND show_donation_page = :s ORDER BY sort_name\", t=self.e.key, s=True)\n        return qCache(q)\n\n    @property\n    def members_dict(self):\n        memcache_key = \"teammembersdict\" +  self.e.websafe\n        members = self.members\n    \n        def get_item():\n            members_dict = {}\n            for tl in members:\n                i = tl.individual.get()\n                members_dict[i.name] = i.websafe\n\n            return members_dict\n\n        return cache(memcache_key, get_item)\n\n    @property\n    def members_list(self):\n        memcache_key = \"teammembers\" +  self.e.websafe\n        \n        def get_item():\n            members = self.members_public_donation_page\n            all_members = []\n\n            for tl in members:\n                tl_key = tl.individual.urlsafe()\n                member = []\n                member.append(tl.individual_name)\n                member.append(tl.individual.get().data.photo_url)        \n                member.append(tl_key)\n\n                #Attaching this to the main array\n                all_members.append(member)\n\n            return all_members\n\n        return cache(memcache_key, get_item)\n\nclass TeamSearch(UtilitiesBase):\n    def createDocument(self):\n        t = self.e\n\n        document = search.Document(doc_id=t.websafe,\n            fields=[search.TextField(name='team_key', value=t.websafe),\n                    search.TextField(name='name', value=t.name),\n                    search.DateField(name='created', value=t.creation_date),\n                    search.TextField(name='settings', value=t.settings.urlsafe()),\n                    ])\n\n        return document\n\n    def index(self):\n        # Updates search index of this entity or creates new one if it doesn't exist\n        index = search.Index(name=_TEAM_SEARCH_INDEX)\n\n        # Creating the new index\n        try:\n            doc = self.createDocument()\n            index.put(doc)\n        except:\n            logging.error(\"Failed creating index on contact key:\" + self.e.websafe)\n\n## -- Dictionary Difference Class -- ##\nclass DictDiffer(object):\n    \"\"\"\n    Calculate the difference between two dictionaries as:\n    (1) items added\n    (2) items removed\n    (3) keys same in both but changed values\n    (4) keys same in both and unchanged values\n    \"\"\"\n    def __init__(self, current_dict, past_dict):\n        self.current_dict, self.past_dict = current_dict, past_dict\n        self.set_current, self.set_past = set(current_dict.keys()), set(past_dict.keys())\n        self.intersect = self.set_current.intersection(self.set_past)\n    def added(self):\n        return self.set_current - self.intersect\n    def removed(self):\n        return self.set_past - self.intersect\n    def changed(self):\n        return set(o for o in self.intersect if self.past_dict[o] != self.current_dict[o])\n    def unchanged(self):\n        return set(o for o in self.intersect if self.past_dict[o] == self.current_dict[o])\n    \n###### ------ Time classes ------ ######\n\nclass EST(tzinfo): \n    def utcoffset(self,dt): \n        return timedelta(hours=-4,minutes=0) \n    def tzname(self,dt): \n        return \"GMT -4\" \n    def dst(self,dt): \n        return timedelta(0) \n\nclass UTC(tzinfo):\n    def utcoffset(self, dt):\n        return timedelta(0)\n    def tzname(self, dt):\n        return \"UTC\"\n    def dst(self, dt):\n        return timedelta(0)\n"]],"start1":0,"start2":0,"length1":0,"length2":49522}]],"length":49522}
{"contributors":[],"silentsave":true,"ts":1363003179855,"patch":[[{"diffs":[[0,"(donation_total)"],[1,"."],[0,"\n\n        item ="]],"start1":41452,"start2":41452,"length1":32,"length2":33}]],"length":49523,"saved":false}
{"ts":1363003181380,"patch":[[{"diffs":[[0,"_total)."],[1,"lower()"],[0,"\n\n      "]],"start1":41461,"start2":41461,"length1":16,"length2":23}]],"length":49530,"saved":false}
{"ts":1363003192303,"patch":[[{"diffs":[[0,"otal"],[-1,").lower()"],[0,"\n\n  "]],"start1":41463,"start2":41463,"length1":17,"length2":8}]],"length":49521,"saved":false}
{"ts":1363003194122,"patch":[[{"diffs":[[0,"r(donation_total"],[1,")"],[0,"\n\n        item ="]],"start1":41451,"start2":41451,"length1":32,"length2":33}]],"length":49522,"saved":false}
